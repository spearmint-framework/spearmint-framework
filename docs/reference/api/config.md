# Config Object

The `Config` class is the core data structure for managing experiment configurations.

## Overview

`Config` is a Pydantic model that wraps a dictionary and provides:
- Dict-like access (`config['key']`)
- Dot notation access (`config.key`)
- Automatic `config_id` generation
- Type validation via Pydantic

## Class Definition

``````python
from pydantic import RootModel

class Config(RootModel[dict[str, Any]]):
    """Configuration model for experiment parameters."""
    
    root: dict[str, Any]
``````

## Creation

### From Dictionary

``````python
from spearmint import Config

config = Config({"model": "gpt-4", "temperature": 0.7})
``````

### From Pydantic Model

``````python
from pydantic import BaseModel
from spearmint import Config

class ModelConfig(BaseModel):
    model: str
    temperature: float

model_cfg = ModelConfig(model="gpt-4", temperature=0.7)
config = Config(model_cfg.model_dump())
``````

### Via Spearmint

Configs are typically created automatically when you initialize Spearmint:

``````python
from spearmint import Spearmint

# Created from dicts
mint = Spearmint(configs=[
    {"model": "gpt-4", "temperature": 0.7},
    {"model": "gpt-3.5-turbo", "temperature": 0.5}
])
``````

## Accessing Values

### Dictionary Access

``````python
config = Config({"model": "gpt-4", "temperature": 0.7})

# Get values
model = config["model"]  # "gpt-4"
temp = config["temperature"]  # 0.7

# Set values
config["max_tokens"] = 1000

# Check existence
if "model" in config:
    print("Model is configured")
``````

### Dot Notation

``````python
config = Config({"model": "gpt-4", "temperature": 0.7})

# Access via attributes
model = config.model  # "gpt-4"
temp = config.temperature  # 0.7

# Note: Setting via dot notation is not supported
# config.model = "gpt-3.5"  # This won't work as expected
``````

### Nested Access

``````python
config = Config({
    "llm": {
        "model": "gpt-4",
        "params": {
            "temperature": 0.7,
            "max_tokens": 1000
        }
    }
})

# Dict-style nested access
model = config["llm"]["model"]
temp = config["llm"]["params"]["temperature"]

# Dot notation nested access
model = config.llm["model"]
temp = config.llm["params"]["temperature"]
``````

## Config ID

Every `Config` automatically gets a unique `config_id`.

### Automatic Generation

``````python
config = Config({"model": "gpt-4", "temperature": 0.7})

# Config ID is auto-generated from content hash
print(config["config_id"])  # "a3f2c8b1d4e5f6g7"
``````

### Explicit Config ID

``````python
# Provide your own ID
config = Config({
    "config_id": "my-custom-id",
    "model": "gpt-4",
    "temperature": 0.7
})

print(config["config_id"])  # "my-custom-id"
``````

### Config ID Generation Algorithm

The `config_id` is generated by:
1. Excluding `config_id` from the config dict
2. Sorting keys for deterministic ordering
3. Computing SHA-256 hash of JSON representation
4. Taking first 16 characters of hex digest

``````python
import hashlib
import json

def generate_config_id(config: dict) -> str:
    config_copy = {k: v for k, v in config.items() if k != "config_id"}
    normalized = json.dumps(config_copy, sort_keys=True, default=str)
    hash_obj = hashlib.sha256(normalized.encode("utf-8"))
    return hash_obj.hexdigest()[:16]
``````

## In Function Signatures

### Basic Usage

``````python
from spearmint import Config

@mint.experiment()
def my_function(prompt: str, config: Config) -> str:
    model = config["model"]
    return f"{model}: {prompt}"
``````

### With Type Hints

``````python
from spearmint import Config

@mint.experiment()
def my_function(prompt: str, config: Config) -> str:
    # IDE knows config is Config type
    # Can use dict-like or dot notation
    return f"{config.model}: {prompt}"
``````

### Type-Safe Alternative with Binding

For full type safety, use Pydantic models with binding:

``````python
from typing import Annotated
from pydantic import BaseModel
from spearmint import Config
from spearmint.configuration import Bind

class ModelConfig(BaseModel):
    model: str
    temperature: float

@mint.experiment()
def my_function(prompt: str, config: Annotated[ModelConfig, Bind("")]) -> str:
    # config is now ModelConfig with full type checking
    return f"{config.model}: {prompt}"
``````

## Validation

Config uses Pydantic's validation:

``````python
from pydantic import BaseModel, Field
from spearmint import Config

class ValidatedConfig(BaseModel):
    model: str
    temperature: float = Field(ge=0.0, le=2.0)

# This will validate
cfg_dict = {"model": "gpt-4", "temperature": 0.7}
valid_cfg = ValidatedConfig(**cfg_dict)
config = Config(valid_cfg.model_dump())

# This will raise ValidationError
try:
    invalid_cfg = ValidatedConfig(model="gpt-4", temperature=3.0)
except ValueError as e:
    print(f"Validation failed: {e}")
``````

## Immutability Considerations

While `Config` allows item assignment, it's recommended to treat configs as immutable during experiment execution:

``````python
@mint.experiment()
def my_function(config: Config) -> str:
    # ✅ Good: Read from config
    model = config["model"]
    
    # ⚠️ Avoid: Modifying config during execution
    # config["model"] = "different-model"
    
    return f"Using {model}"
``````

## Serialization

### To Dictionary

``````python
config = Config({"model": "gpt-4", "temperature": 0.7})

# Get underlying dict
config_dict = config.root
print(config_dict)  # {'model': 'gpt-4', 'temperature': 0.7, 'config_id': '...'}
``````

### To JSON

``````python
import json

config = Config({"model": "gpt-4", "temperature": 0.7})

# Serialize to JSON
json_str = json.dumps(config.root)
print(json_str)

# Deserialize from JSON
config_dict = json.loads(json_str)
restored_config = Config(config_dict)
``````

## Comparison

Configs with the same content (excluding `config_id`) will have the same `config_id`:

``````python
config1 = Config({"model": "gpt-4", "temperature": 0.7})
config2 = Config({"model": "gpt-4", "temperature": 0.7})

# Same content = same ID
assert config1["config_id"] == config2["config_id"]
``````

## Examples

### Configuration with Defaults

``````python
config = Config({
    "model": "gpt-4",
    "temperature": 0.7,
    "max_tokens": 1000,
    "top_p": 1.0,
    "frequency_penalty": 0.0,
    "presence_penalty": 0.0
})

@mint.experiment()
def generate(prompt: str, config: Config) -> str:
    # Use config values with defaults
    model = config.get("model", "gpt-3.5-turbo")
    temp = config.get("temperature", 0.5)
    
    # Note: config.get() requires dict-like access
    # Use config.root.get() for safety
    max_tokens = config.root.get("max_tokens", 500)
    
    return call_llm(prompt, model, temp, max_tokens)
``````

### Hierarchical Configuration

``````python
config = Config({
    "model_config": {
        "provider": "openai",
        "model": "gpt-4",
        "parameters": {
            "temperature": 0.7,
            "max_tokens": 1000
        }
    },
    "retry_config": {
        "max_retries": 3,
        "backoff_factor": 2.0
    }
})

@mint.experiment()
def robust_generate(prompt: str, config: Config) -> str:
    model_cfg = config["model_config"]
    retry_cfg = config["retry_config"]
    
    return generate_with_retry(
        prompt,
        model=model_cfg["model"],
        params=model_cfg["parameters"],
        retries=retry_cfg["max_retries"]
    )
``````

## See Also

- [DynamicValue](dynamic-value.md) - Generate multiple configs
- [Config Parsing](config-parsing.md) - Loading configs from files
- [Config Binding](config-binding.md) - Type-safe configuration
- [Config IDs](../config-ids.md) - Understanding config identification
- [YAML Format](../yaml-format.md) - YAML configuration files
